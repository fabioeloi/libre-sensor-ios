package global.camomile.libresensor

import java.util.concurrent.TimeUnit

data class Sensor (
    val serialNumber: String,
    val startDate: Long,
    val ageInMinutes: Int,
    val state: SensorState,
    val region: SensorRegion
) {
    val timeLeft = timeLeft(startDate, ageInMinutes)
    val readyInMinutes = readyInMinutes(ageInMinutes)

    constructor(rawTagData: RawTag) : this(
        sensorSerialNumber(hexStringToBytes(rawTagData.tagId)),
        getStartTimestamp(rawTagData.tagDate, rawTagData.sensorAgeInMinutes),
        rawTagData.sensorAgeInMinutes,
        SensorState.from(rawTagData.sensorState),
        SensorRegion.from(rawTagData.sensorRegion)
    )

    fun timeLeftAt(atTime: Long): Long {
        return timeLeftAt(startDate, atTime)
    }

    companion object {
        // data generated by the sensor in the first 60 minutes is not correct
        const val sensorInitializationInMinutes = 60
        // data generated by the sensor after 14 days also has faults
        const val maxSensorAgeInMinutes : Long = 20160 // 14 * 24 * 60

        fun timeLeft(startDate: Long, ageInMinutes: Int): Long {
            return TimeUnit.MINUTES.toMillis(maxSensorAgeInMinutes - ageInMinutes)
                .coerceAtLeast(0)
        }

        fun timeLeftAt(startDate: Long, atTime: Long): Long {
            return (startDate + TimeUnit.MINUTES.toMillis(maxSensorAgeInMinutes) - atTime)
                .coerceAtLeast(0)
        }

        fun readyInMinutes(ageInMinutes: Int): Int {
            return (sensorInitializationInMinutes - ageInMinutes).coerceAtLeast(0)
        }

        fun getStartTimestamp(tagDate: Long, sensorAgeInMinutes: Int): Long {
            return tagDate - tagDate % TimeUnit.MINUTES.toMillis(1) -
                    TimeUnit.MINUTES.toMillis(sensorAgeInMinutes.toLong())
        }

        // Explanation https://github.com/UPetersen/LibreMonitor/wiki#serial-number
        private fun sensorSerialNumber(data: ByteArray): String {
            val lookupTable = arrayOf("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R", "T", "U", "V", "W", "X", "Y", "Z")

            if (data.size != 8){
                return ""
            }

            val bytes = data.reversed().takeLast(6).toByteArray()
            val fiveBitsArray = mutableListOf<UInt>()

            fiveBitsArray.add((bytes[0].toInt() shr 3).toUInt())
            fiveBitsArray.add(((bytes[0].toInt() shl 2) or (bytes[1].toInt() shr 6)).toUInt())

            fiveBitsArray.add((bytes[1].toInt() shr 1).toUInt())
            fiveBitsArray.add(((bytes[1].toInt() shl 4) or (bytes[2].toInt() shr 4)).toUInt())

            fiveBitsArray.add(((bytes[2].toInt() shl 1) or (bytes[3].toInt() shr 7)).toUInt())

            fiveBitsArray.add((bytes[3].toInt() shr 2).toUInt())
            fiveBitsArray.add(((bytes[3].toInt() shl 3) or (bytes[4].toInt() shr 5)).toUInt())

            fiveBitsArray.add(bytes[4].toUInt())

            fiveBitsArray.add((bytes[5].toInt() shr 3).toUInt())
            fiveBitsArray.add((bytes[5].toInt() shl 2).toUInt())

            return fiveBitsArray.fold("") { acc, value ->
                acc + lookupTable[(0x1f and value.toInt())]
            }
        }

        private fun hexStringToBytes(hexString: String): ByteArray {
            check(hexString.length % 2 == 0) { "Must have an even length" }

            return hexString.chunked(2)
                .map { it.toInt(16).toByte() }
                .toByteArray()
        }
    }
}